<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Physics Sandbox</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <style>
        #gameCanvas {
            background-color: #1a202c;
            touch-action: none;
        }
        .material-btn.active {
            transform: scale(1.1);
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        .particle {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
        }
        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .tooltip.show {
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-900 text-white overflow-hidden">
    <div class="container mx-auto px-4 py-4">
        <div class="flex justify-between items-center mb-4">
            <h1 class="text-2xl font-bold">2D Physics Sandbox</h1>
            <div class="flex space-x-2">
                <button id="clearBtn" class="bg-red-600 hover:bg-red-700 px-4 py-2 rounded-lg transition">Clear All</button>
                <button id="helpBtn" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-lg transition">Help</button>
            </div>
        </div>
        
        <div class="flex flex-wrap gap-2 mb-4">
            <button data-material="sand" class="material-btn bg-yellow-500 hover:bg-yellow-600 px-4 py-2 rounded-lg transition active">Sand</button>
            <button data-material="water" class="material-btn bg-blue-500 hover:bg-blue-600 px-4 py-2 rounded-lg transition">Water</button>
            <button data-material="stone" class="material-btn bg-gray-500 hover:bg-gray-600 px-4 py-2 rounded-lg transition">Stone</button>
            <button data-material="wood" class="material-btn bg-amber-700 hover:bg-amber-800 px-4 py-2 rounded-lg transition">Wood</button>
            <button data-material="lava" class="material-btn bg-red-600 hover:bg-red-700 px-4 py-2 rounded-lg transition">Lava</button>
            <button data-material="erase" class="material-btn bg-gray-800 hover:bg-gray-700 px-4 py-2 rounded-lg transition">Eraser</button>
        </div>
        
        <div class="flex gap-4 mb-4">
            <div>
                <label class="block mb-1">Brush Size</label>
                <input id="brushSize" type="range" min="5" max="50" value="15" class="w-40">
                <span id="brushSizeValue">15</span>
            </div>
            <div>
                <label class="block mb-1">Gravity</label>
                <input id="gravitySlider" type="range" min="-2" max="2" step="0.1" value="1" class="w-40">
                <span id="gravityValue">1.0</span>
            </div>
        </div>
        
        <div class="relative">
            <canvas id="gameCanvas" width="800" height="500" class="w-full border-2 border-gray-700 rounded-lg"></canvas>
            <div id="tooltip" class="tooltip"></div>
        </div>
        
        <div class="mt-4 text-sm text-gray-400">
            <p>Click/drag to place materials. Right-click to erase. Scroll to adjust brush size.</p>
        </div>
    </div>

    <div id="helpModal" class="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center hidden z-50">
        <div class="bg-gray-800 p-6 rounded-lg max-w-2xl mx-4">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold">Sandbox Game Help</h2>
                <button id="closeHelp" class="text-gray-400 hover:text-white text-2xl">&times;</button>
            </div>
            <div class="space-y-4">
                <div>
                    <h3 class="font-semibold text-blue-400">Materials</h3>
                    <ul class="list-disc pl-5 mt-2 space-y-1">
                        <li><span class="text-yellow-500">Sand</span> - Falls and forms piles</li>
                        <li><span class="text-blue-500">Water</span> - Flows and spreads</li>
                        <li><span class="text-gray-500">Stone</span> - Solid and immovable</li>
                        <li><span class="text-amber-700">Wood</span> - Floats on water</li>
                        <li><span class="text-red-600">Lava</span> - Burns wood, turns to stone when touching water</li>
                    </ul>
                </div>
                <div>
                    <h3 class="font-semibold text-blue-400">Controls</h3>
                    <ul class="list-disc pl-5 mt-2 space-y-1">
                        <li>Left-click: Place selected material</li>
                        <li>Right-click: Erase materials</li>
                        <li>Mouse wheel: Adjust brush size</li>
                        <li>Clear button: Reset the entire canvas</li>
                    </ul>
                </div>
                <div>
                    <h3 class="font-semibold text-blue-400">Physics</h3>
                    <p>Adjust gravity with the slider to see how materials behave differently.</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game setup
        document.addEventListener('DOMContentLoaded', function() {
            // Matter.js setup
            const Engine = Matter.Engine,
                  Render = Matter.Render,
                  World = Matter.World,
                  Bodies = Matter.Bodies,
                  Body = Matter.Body,
                  Events = Matter.Events,
                  Composite = Matter.Composite;
            
            // Create engine
            const engine = Engine.create({
                gravity: { x: 0, y: 1 },
                enableSleeping: true
            });
            
            // Get canvas and context
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            // Adjust canvas size
            function resizeCanvas() {
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = Math.min(container.clientWidth * 0.625, window.innerHeight * 0.7);
            }
            
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            
            // Game state
            let selectedMaterial = 'sand';
            let brushSize = 15;
            let isDrawing = false;
            let isErasing = false;
            let particles = [];
            let bodies = [];
            let lastSpawnTime = 0;
            const spawnInterval = 50; // ms
            
            // Materials properties
            const materials = {
                sand: {
                    color: '#e3a008',
                    density: 0.7,
                    friction: 0.3,
                    restitution: 0.1,
                    render: { fillStyle: '#e3a008' },
                    isStatic: false,
                    frictionAir: 0.01
                },
                water: {
                    color: '#3b82f6',
                    density: 0.5,
                    friction: 0.1,
                    restitution: 0.01,
                    render: { fillStyle: '#3b82f6' },
                    isStatic: false,
                    frictionAir: 0.05
                },
                stone: {
                    color: '#6b7280',
                    density: 2.5,
                    friction: 0.8,
                    restitution: 0.2,
                    render: { fillStyle: '#6b7280' },
                    isStatic: true
                },
                wood: {
                    color: '#92400e',
                    density: 0.3,
                    friction: 0.5,
                    restitution: 0.4,
                    render: { fillStyle: '#92400e' },
                    isStatic: false,
                    frictionAir: 0.02
                },
                lava: {
                    color: '#dc2626',
                    density: 1.2,
                    friction: 0.2,
                    restitution: 0.1,
                    render: { fillStyle: '#dc2626' },
                    isStatic: false,
                    frictionAir: 0.01
                }
            };
            
            // Create boundary walls
            const wallOptions = { isStatic: true, render: { fillStyle: '#4a5568' } };
            const walls = [
                Bodies.rectangle(canvas.width / 2, canvas.height, canvas.width, 20, { ...wallOptions, chamfer: { radius: 10 } }), // bottom
                Bodies.rectangle(canvas.width / 2, 0, canvas.width, 20, wallOptions), // top
                Bodies.rectangle(0, canvas.height / 2, 20, canvas.height, wallOptions), // left
                Bodies.rectangle(canvas.width, canvas.height / 2, 20, canvas.height, wallOptions) // right
            ];
            
            World.add(engine.world, walls);
            
            // UI event listeners
            document.querySelectorAll('.material-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.material-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    selectedMaterial = this.dataset.material;
                });
            });
            
            document.getElementById('brushSize').addEventListener('input', function() {
                brushSize = parseInt(this.value);
                document.getElementById('brushSizeValue').textContent = brushSize;
            });
            
            document.getElementById('gravitySlider').addEventListener('input', function() {
                const gravity = parseFloat(this.value);
                engine.gravity.y = gravity;
                document.getElementById('gravityValue').textContent = gravity.toFixed(1);
            });
            
            document.getElementById('clearBtn').addEventListener('click', function() {
                // Remove all bodies except walls
                Composite.allBodies(engine.world).forEach(body => {
                    if (!walls.includes(body)) {
                        World.remove(engine.world, body);
                    }
                });
                bodies = [];
            });
            
            // Help modal
            const helpModal = document.getElementById('helpModal');
            document.getElementById('helpBtn').addEventListener('click', () => helpModal.classList.remove('hidden'));
            document.getElementById('closeHelp').addEventListener('click', () => helpModal.classList.add('hidden'));
            helpModal.addEventListener('click', (e) => {
                if (e.target === helpModal) helpModal.classList.add('hidden');
            });
            
            // Tooltip
            const tooltip = document.getElementById('tooltip');
            
            // Canvas interaction
            canvas.addEventListener('mousedown', (e) => {
                if (e.button === 0) { // left click
                    isDrawing = true;
                    if (selectedMaterial === 'erase') {
                        isErasing = true;
                    } else {
                        addMaterial(e.clientX, e.clientY);
                    }
                } else if (e.button === 2) { // right click
                    isErasing = true;
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                // Update tooltip position
                const x = e.clientX;
                const y = e.clientY;
                
                tooltip.style.left = `0px`;
                tooltip.style.top = `0px`;
                
                // Show tooltip with coordinates
                tooltip.textContent = `X: ${Math.round(x)}, Y: ${Math.round(y)}`;
                tooltip.classList.add('show');
                
                // Drawing/erasing
                const now = Date.now();
                if ((isDrawing || isErasing) && now - lastSpawnTime > spawnInterval) {
                    if (isErasing) {
                        eraseAtPosition(x, y);
                    } else {
                        addMaterial(x, y);
                    }
                    lastSpawnTime = now;
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
                isErasing = false;
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDrawing = false;
                isErasing = false;
                tooltip.classList.remove('show');
            });
            
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            
            // Mouse wheel for brush size
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const brushInput = document.getElementById('brushSize');
                let newSize = brushSize + (e.deltaY > 0 ? -5 : 5);
                newSize = Math.max(5, Math.min(50, newSize));
                brushSize = newSize;
                brushInput.value = newSize;
                document.getElementById('brushSizeValue').textContent = newSize;
            });
            
            // Add material at position
            function addMaterial(x, y) {
                const rect = canvas.getBoundingClientRect();
                const canvasX = x - rect.left;
                const canvasY = y - rect.top;
                
                // Check if position is within canvas
                if (canvasX < 20 || canvasX > canvas.width - 20 || 
                    canvasY < 20 || canvasY > canvas.height - 20) return;
                
                const material = materials[selectedMaterial];
                const size = brushSize;
                
                // Create a new body
                const body = Bodies.circle(canvasX, canvasY, size/2, {
                    ...material,
                    render: {
                        ...material.render,
                        strokeStyle: '#ffffff',
                        lineWidth: 1
                    },
                    label: selectedMaterial
                });
                
                World.add(engine.world, body);
                bodies.push(body);
                
                // Add visual particle effect
                createParticles(canvasX, canvasY, material.color, size);
                
                // Special interactions
                if (selectedMaterial === 'lava') {
                    checkLavaInteractions(body);
                }
            }
            
            // Erase at position
            function eraseAtPosition(x, y) {
                const rect = canvas.getBoundingClientRect();
                const canvasX = x - rect.left;
                const canvasY = y - rect.top;
                
                // Find bodies within brush radius
                const bodiesToRemove = Composite.allBodies(engine.world).filter(body => {
                    if (walls.includes(body)) return false;
                    
                    const distance = Math.sqrt(
                        Math.pow(body.position.x - canvasX, 2) + 
                        Math.pow(body.position.y - canvasY, 2)
                    );
                    
                    return distance < brushSize;
                });
                
                // Remove bodies
                bodiesToRemove.forEach(body => {
                    World.remove(engine.world, body);
                    bodies = bodies.filter(b => b !== body);
                    
                    // Add erase particles
                    createParticles(body.position.x, body.position.y, '#ffffff', brushSize/2, 10);
                });
            }
            
            // Create visual particles
            function createParticles(x, y, color, size, count = 5) {
				const rect = canvas.getBoundingClientRect();
                x += rect.left;
                y += rect.top;
                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.width = `${Math.random() * 4 + 2}px`;
                    particle.style.height = particle.style.width;
                    particle.style.backgroundColor = color;
                    particle.style.left = `${x}px`;
                    particle.style.top = `${y}px`;
                    
                    const angle = Math.random() * Math.PI * 2;
                    const velocity = Math.random() * 5 + 2;
                    const lifetime = Math.random() * 1000 + 500;
                    
                    document.body.appendChild(particle);
                    
                    let startTime = Date.now();
                    
                    function updateParticle() {
                        const elapsed = Date.now() - startTime;
                        const progress = elapsed / lifetime;
                        
                        if (progress >= 1) {
                            particle.remove();
                            return;
                        }
                        
                        const currentX = x + Math.cos(angle) * velocity * elapsed * 0.05;
                        const currentY = y + Math.sin(angle) * velocity * elapsed * 0.05 + (elapsed * 0.001 * engine.gravity.y * 100);
                        
                        particle.style.left = `${currentX}px`;
                        particle.style.top = `${currentY}px`;
                        particle.style.opacity = 1 - progress;
                        
                        requestAnimationFrame(updateParticle);
                    }
                    
                    updateParticle();
                }
            }
            
            // Check for lava interactions
            function checkLavaInteractions(lavaBody) {
                const lavaPos = lavaBody.position;
                
                // Find nearby bodies
                const nearbyBodies = Composite.allBodies(engine.world).filter(body => {
                    if (body === lavaBody || walls.includes(body)) return false;
                    
                    const distance = Math.sqrt(
                        Math.pow(body.position.x - lavaPos.x, 2) + 
                        Math.pow(body.position.y - lavaPos.y, 2)
                    );
                    
                    return distance < (body.circleRadius + laaBody.circleRadius);
                });
                
                nearbyBodies.forEach(body => {
                    // Lava turns water to stone
                    if (body.label === 'water') {
                        // Create stone at water position
                        const stone = Bodies.circle(body.position.x, body.position.y, brushSize/2, {
                            ...materials.stone,
                            render: {
                                ...materials.stone.render,
                                strokeStyle: '#ffffff',
                                lineWidth: 1
                            },
                            label: 'stone'
                        });
                        
                        World.add(engine.world, stone);
                        bodies.push(stone);
                        
                        // Remove the water
                        World.remove(engine.world, body);
                        bodies = bodies.filter(b => b !== body);
						
						// Remove the lava
                        World.remove(engine.world, lavaBody);
                        bodies = bodies.filter(b => b !== lavaBody);
                        
                        // Add steam effect
                        createParticles(body.position.x, body.position.y, '#a5b4fc', brushSize, 15);
                    }
                    
                    // Lava burns wood
                    if (body.label === 'wood') {
                        // Create fire particles
                        createParticles(body.position.x, body.position.y, '#f59e0b', brushSize, 10);
                        
                        // Gradually reduce wood size
                        if (body.circleRadius > 5) {
                            Body.scale(body, 0.95, 0.95);
                        } else {
                            // Remove when too small
                            World.remove(engine.world, body);
                            bodies = bodies.filter(b => b !== body);
                        }
                    }
                });
            }
			
			// Check for wood interactions
            function checkWoodInteractions(woodBody) {
                const woodPos = woodBody.position;
				
                // Find nearby bodies
                const nearbyBodies = Composite.allBodies(engine.world).filter(body => {
                    if (body === woodBody || walls.includes(body)) return false;
                    
                    const distance = Math.sqrt(
                        Math.pow(body.position.x - woodPos.x, 2) + 
                        Math.pow(body.position.y - woodPos.y, 2)
                    );
                    
                    return distance < (body.circleRadius + woodBody.circleRadius);
                });
                
                nearbyBodies.forEach(body => {
                    // Wood floats on water
                    if (body.label === 'water') {
                        woodPos.y -= 0.1 * (engine.gravity.y);
                    }
                });
            }
            
            // Game loop
            function gameLoop() {
                // Update physics
                Engine.update(engine, 1000 / 60);
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw all bodies
                ctx.save();
                Composite.allBodies(engine.world).forEach(body => {
                    if (body.render.visible === false) return;
					
					if (body.label === 'lava') {
						checkLavaInteractions(body);
					}
					
					if (body.label === 'wood') {
						checkWoodInteractions(body);
					}
                    
                    ctx.beginPath();
                    
                    if (body.circleRadius) {
                        // Draw circle
                        ctx.arc(body.position.x, body.position.y, body.circleRadius, 0, Math.PI * 2);
                    } else {
                        // Draw polygon (for walls)
                        ctx.moveTo(body.vertices[0].x, body.vertices[0].y);
                        for (let i = 1; i < body.vertices.length; i++) {
                            ctx.lineTo(body.vertices[i].x, body.vertices[i].y);
                        }
                        ctx.lineTo(body.vertices[0].x, body.vertices[0].y);
                    }
                    
                    ctx.fillStyle = body.render.fillStyle;
                    ctx.fill();
                    
                    if (body.render.strokeStyle) {
                        ctx.strokeStyle = body.render.strokeStyle;
                        ctx.lineWidth = body.render.lineWidth || 1;
                        ctx.stroke();
                    }
                });
                
                ctx.restore();
                
                // Draw brush preview
                if (isDrawing || isErasing) {
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = lastMouseX - rect.left;
                    const mouseY = lastMouseY - rect.top;
                    
                    if (mouseX > 0 && mouseX < canvas.width && mouseY > 0 && mouseY < canvas.height) {
                        ctx.beginPath();
                        ctx.arc(mouseX, mouseY, brushSize, 0, Math.PI * 2);
                        ctx.fillStyle = isErasing ? 'rgba(255, 0, 0, 0.2)' : `${materials[selectedMaterial].color}80`;
                        ctx.fill();
                        ctx.strokeStyle = isErasing ? 'red' : 'white';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }

                requestAnimationFrame(gameLoop);
            }
            
            // Track last mouse position for brush preview
            let lastMouseX = 0;
            let lastMouseY = 0;
            canvas.addEventListener('mousemove', (e) => {
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            });
            
            // Start the game
            gameLoop();
        });
    </script>
</body>
</html>